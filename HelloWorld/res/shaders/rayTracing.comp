#version 460 core
#define M_PI 3.14159265358979

// STRUCTS
struct Transform {
	vec3 position;
	vec3 scale;
	vec2 rotation;
};

struct Ray {
	vec3 origin;
	vec3 direction;
};

uniform struct Camera {
	vec3 position;
	vec2 direction;
	float vFov;
} mainCamera;

struct Hit {
	float depth;
	int index;
	int type;
};

uniform struct Light {
	vec3 direction;
	vec3 color;
	float radius;
} mainLight;

// INPUTS
layout(local_size_x = 8,local_size_y = 8,local_size_z = 1) in;
layout(rgba16f, binding = 0) uniform image2D image;

layout(std430, binding = 2) readonly restrict buffer ColorBuffer {
	vec4 _color_roughness[];
};

uniform int selectedIndex;
uniform ivec2 mousePos;
uniform int frameIndex;
uniform int AAsamples;

// FUNCTIONS
vec3 skyColor(vec3 rayDirection);

Hit launchRay(Ray ray, int originIndex);
Ray generateRay(ivec2 pixelCoords, ivec2 imSize, Camera camera);
Ray generateRayOffset(ivec2 pixelCoords, ivec2 imSize, Camera camera, vec2 offset);
vec3 computeNormal(Hit hit, Ray ray);

vec3 drawTools(Ray ray, vec3 pixelColor);

vec3 BRDF(Light light, vec3 normal, vec3 color, float ambient) {
	return light.color * light.radius * light.radius * M_PI * color * max(dot(normal,-light.direction),0) + ambient * color;
}

float randFloat(uint seed, float a, float b) {
	uint state = seed*747796405u + 2891336453u;
	uint word = ((state >> ((state>>28u)+4u))^state)*277803737;
	word = (word>>22u)^word;
	return a+(b-a)*float(word)/(-1u);
}

vec3 randVec3(uint seed, float a, float b) {
	return vec3(randFloat(seed, a, b), randFloat(3 * seed + 57, a, b), randFloat(4 * seed + 1023, a, b));
}

vec2 randVec2(uint seed, float a, float b) {
	return vec2(randFloat(seed, a, b), randFloat(3 * seed + 57, a, b));
}

vec3 randVecSphere(uint seed) {
	float phi = randFloat(seed, 0, 2 * M_PI);
	float theta = acos(randFloat(seed * 51797 + 47464, -1, 1));
	return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));
}

uint getSeed(bool timeDependant) {
	if(timeDependant) return gl_GlobalInvocationID.x + 7491304 * gl_GlobalInvocationID.y + 435179 * frameIndex;
	else return gl_GlobalInvocationID.x + 74913 * gl_GlobalInvocationID.y;
}


// MAIN LOOP
void main()
{
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	Ray ray = generateRay(pixelCoords, imageSize(image), mainCamera);

	vec3 skyColor = 0 * skyColor(ray.direction);
	if(dot(ray.direction,-mainLight.direction)>cos(mainLight.radius)) {
		skyColor = mainLight.color;
	}

	Hit hit = launchRay(ray, -1);
	vec3 pixelColor = skyColor;
	bool hitSelected = false;
	if(hit.index!=-1) {
		vec3 normal =  computeNormal(hit, ray);
		pixelColor = BRDF(mainLight, normal, vec3(_color_roughness[hit.index].xyz), 0);
		if(hit.index == selectedIndex) hitSelected = true;

		if(AAsamples > 0) {
			Ray ray2;
			ray2.origin = ray.origin + ray.direction * hit.depth;
			vec3 ambientColor;
			for(int i = 0; i < AAsamples; i++) {
				ray2.direction = randVecSphere(getSeed(true) + 1209492 * i);
				if(dot(ray2.direction, normal) < 0) ray2.direction = -ray2.direction;

				Hit hit2 = launchRay(ray2, hit.index);
				if(hit2.index != -1) {
					vec3 normal2 =  computeNormal(hit2, ray2);
					vec3 hitColor = BRDF(mainLight, normal2, _color_roughness[hit2.index].xyz, 0) * _color_roughness[hit.index].xyz;
					ambientColor += hitColor * M_PI * dot(ray2.direction, normal)/2;
				}
			}
			pixelColor += ambientColor / AAsamples;
		}
	}

//	for(int i = 0; i < AAsamples; i++) {
//		ray = generateRayOffset(pixelCoords, imageSize(image), mainCamera, randVec2(i,-.5,.5));
//		hit = launchRay(ray);
//		if(hit.index!=-1) {
//			vec3 normal =  computeNormal(hit, ray);
//			pixelColor += BRDF(mainLight, normal, vec3(1));
//			if(hit.index == selectedIndex) hitSelected = true;
//		}
//		else pixelColor += skyColor;
//	}
//	pixelColor /= (1 + AAsamples);


	if(hitSelected) pixelColor *= vec3(.95);
	if(selectedIndex!= -1) {
		pixelColor = drawTools(ray, pixelColor);
	}

	//pixelColor = _color_roughness[hit.index].xyz;
	
	imageStore(image, pixelCoords, vec4(sqrt(pixelColor),1));
}


